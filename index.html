<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æˆèªå¤§äº‚é¬¥ (è±ªè¯ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@500;900&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #2a2a2a;
            user-select: none;
            height: 100dvh; 
            width: 100vw;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
        }

        /* UI å±¤æ¬¡ */
        .ui-layer { position: absolute; pointer-events: none; z-index: 10; }
        .interactive-layer { position: absolute; z-index: 50; }

        /* éœ“è™¹ç‡ˆæ•ˆæœæ–‡å­— */
        .neon-text {
            text-shadow: 0 0 5px rgba(255,255,255,0.8), 0 0 10px rgba(255,255,255,0.5);
        }

        .pixel-card {
            background: rgba(255, 255, 255, 0.95);
            border: 4px solid #3b82f6;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.2);
            border-radius: 16px;
        }

        /* ç©å®¶é ­åƒé è¦½ */
        .avatar-preview {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 6px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            object-fit: cover;
            background: #f3f4f6;
        }

        /* è¡¨æƒ…æŒ‰éˆ•ç¶²æ ¼ */
        .emote-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            pointer-events: auto;
        }
        .emote-btn {
            background: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid #ddd;
            transition: transform 0.1s;
        }
        .emote-btn:active { transform: scale(0.9); }
    </style>
</head>
<body>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay: Top HUD -->
    <div id="gameUI" class="ui-layer inset-0 hidden flex flex-col justify-between p-2">
        <!-- Scoreboard -->
        <div class="flex justify-between items-start w-full gap-2 max-w-4xl mx-auto" id="scoreboardArea">
            <!-- JS will populate scores here -->
        </div>

        <!-- Question Display (Floating) -->
        <div class="absolute top-24 left-0 w-full flex justify-center">
             <div class="bg-white/90 backdrop-blur-sm border-b-8 border-r-8 border-blue-600 border-t-2 border-l-2 border-blue-400 rounded-2xl px-6 py-4 shadow-2xl text-center min-w-[280px] transform hover:scale-105 transition-transform duration-300">
                 <p class="text-blue-500 text-xs font-black tracking-widest mb-1">è«‹æ¥ä½ç¼ºå­—ï¼</p>
                 <h1 id="idiomDisplay" class="text-4xl md:text-6xl font-black text-gray-800 tracking-widest whitespace-nowrap overflow-hidden text-ellipsis drop-shadow-md">
                    æº–å‚™ä¸­...
                </h1>
            </div>
        </div>
        
        <!-- Emote Bar (Bottom Right) -->
        <div class="absolute bottom-20 right-4 interactive-layer">
            <div class="emote-grid">
                <button class="emote-btn" onclick="sendEmote('ğŸ˜¡')">ğŸ˜¡</button>
                <button class="emote-btn" onclick="sendEmote('ğŸ˜‚')">ğŸ˜‚</button>
                <button class="emote-btn" onclick="sendEmote('ğŸ˜±')">ğŸ˜±</button>
                <button class="emote-btn" onclick="sendEmote('å¿«è·‘')">ğŸ’¨</button>
                <button class="emote-btn" onclick="sendEmote('æ¨!')">ğŸ‘‹</button>
                <button class="emote-btn" onclick="sendEmote('è´äº†')">âœŒï¸</button>
            </div>
        </div>

        <!-- Room Info -->
        <div class="text-center pb-6">
             <span class="bg-black/40 backdrop-blur text-white px-4 py-1 rounded-full text-sm font-bold font-mono border border-white/30" id="roomCodeDisplay">ROOM: ----</span>
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="absolute inset-0 bg-gradient-to-br from-yellow-300 via-orange-300 to-red-300 flex flex-col items-center justify-center z-50 p-4 overflow-y-auto">
        
        <div class="pixel-card p-6 md:p-10 w-full max-w-md text-center relative overflow-hidden">
            <!-- Background Decoration -->
            <div class="absolute -top-10 -right-10 w-32 h-32 bg-yellow-200 rounded-full opacity-50"></div>
            
            <h1 class="text-4xl md:text-5xl font-black text-blue-600 mb-2 relative z-10" style="text-shadow: 2px 2px 0px white;">âš¡ æˆèªå¤§äº‚é¬¥ âš¡</h1>
            <p class="text-gray-500 mb-6 font-bold tracking-widest relative z-10">è±ªè¯è¦–è¦ºç‰ˆ</p>

            <div id="authSection" class="mb-4">
                 <p class="text-gray-400 text-sm font-bold animate-pulse">é€£ç·šä¼ºæœå™¨ä¸­...</p>
                 <p id="authError" class="text-red-500 text-xs hidden mt-2">é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯</p>
            </div>

            <!-- Avatar -->
            <div id="avatarSection" class="mb-6 hidden animate-fade-in relative z-10">
                <div class="flex justify-center mb-4 relative group cursor-pointer" onclick="document.getElementById('avatarInput').click()">
                    <img id="avatarPreview" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png" class="avatar-preview bg-yellow-100">
                    <div class="absolute bottom-0 right-[35%] bg-blue-500 text-white rounded-full p-2 border-2 border-white shadow-lg">
                        <i class="fas fa-camera"></i>
                    </div>
                </div>
                <input type="file" id="avatarInput" accept="image/*" class="hidden" onchange="handleAvatarUpload(this)">
                <input type="text" id="playerName" placeholder="è¼¸å…¥ä½ çš„å¤§å" maxlength="6" class="w-full bg-gray-50 border-2 border-gray-200 rounded-xl px-4 py-3 text-center font-bold text-lg focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition mb-2" value="è¨“ç·´å®¶">
            </div>

            <div id="menuSection" class="hidden space-y-4 relative z-10">
                <button id="createBtn" class="w-full bg-gradient-to-r from-yellow-400 to-yellow-500 hover:from-yellow-500 hover:to-yellow-600 text-white font-black py-4 rounded-xl shadow-lg transform active:scale-95 transition flex items-center justify-center gap-2 text-xl border-b-4 border-yellow-700">
                    <i class="fas fa-crown"></i> å»ºç«‹æˆ¿é–“ (Host)
                </button>
                
                <div class="flex items-center gap-3 opacity-60">
                    <div class="h-0.5 bg-gray-300 flex-1"></div>
                    <span class="text-gray-400 text-xs font-bold">OR</span>
                    <div class="h-0.5 bg-gray-300 flex-1"></div>
                </div>

                <div class="flex gap-2">
                    <input type="text" id="roomInput" placeholder="æˆ¿è™Ÿ" maxlength="4" class="flex-1 bg-gray-50 border-2 border-gray-300 rounded-xl px-2 py-2 text-center font-black text-2xl uppercase tracking-widest focus:outline-none focus:border-blue-500 min-w-0">
                    <button id="joinBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold px-6 py-2 rounded-xl shadow-lg border-b-4 border-blue-700 active:border-b-0 active:translate-y-1 transition whitespace-nowrap">
                        åŠ å…¥
                    </button>
                </div>
            </div>

            <div id="waitingSection" class="hidden text-center py-4 relative z-10">
                <div class="animate-spin text-5xl text-blue-500 mb-6"><i class="fas fa-circle-notch"></i></div>
                <h3 class="text-xl font-bold text-gray-800 mb-2">å¤§å»³ç­‰å€™ä¸­...</h3>
                
                <div class="bg-gray-100 p-4 rounded-2xl mb-6 border-2 border-dashed border-gray-300">
                    <p class="text-xs text-gray-500 font-bold mb-1">æˆ¿é–“è™Ÿç¢¼</p>
                    <p class="text-5xl font-mono font-black text-blue-600 tracking-[0.2em]" id="generatedRoomCode">----</p>
                </div>
                
                <div id="playerList" class="flex justify-center flex-wrap gap-4 mb-8 min-h-[80px]">
                    <!-- Player icons -->
                </div>

                <button id="startGameBtn" class="hidden w-full bg-gradient-to-r from-green-400 to-green-500 hover:from-green-500 hover:to-green-600 text-white font-black py-4 rounded-xl shadow-xl border-b-4 border-green-700 active:border-b-0 active:translate-y-1 transition animate-bounce text-xl">
                    ğŸš€ é–‹å§‹å°æˆ°ï¼
                </button>
                <p id="waitingText" class="text-sm text-gray-500 font-bold bg-white/50 px-3 py-1 rounded-full inline-block">ç­‰å¾…å…¶ä»–è¨“ç·´å®¶åŠ å…¥...</p>
            </div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center z-50 pointer-events-auto">
        <div class="pixel-card p-8 max-w-md w-[90%] text-center animate-bounce-in">
            <div class="text-6xl mb-2">ğŸ‘‘</div>
            <h2 class="text-4xl font-black text-gray-800 mb-6" id="winnerText">æ¯”è³½çµæŸï¼</h2>
            <div class="flex flex-col gap-3 mb-8 w-full max-h-[40vh] overflow-y-auto" id="finalScores">
                <!-- Scores -->
            </div>
            <button onclick="location.reload()" class="w-full bg-blue-500 text-white font-bold py-4 rounded-xl shadow-lg hover:bg-blue-600 transition border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
                å†ç©ä¸€æ¬¡
            </button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const MANUAL_CONFIG = { apiKey: "AIzaSyCTzlspfVyvt_c9Iamfs73Q39BSsGKXmbo",
Â  authDomain: "pikachu-party.firebaseapp.com",
Â  projectId: "pikachu-party",
Â  storageBucket: "pikachu-party.firebasestorage.app",
Â  messagingSenderId: "409348876468",
Â  appId: "1:409348876468:web:0f452361c54675386d0fe1",
Â  measurementId: "G-H4P2MX0HJ6"};
        let firebaseConfig;
        try { firebaseConfig = JSON.parse(__firebase_config); } catch (e) { firebaseConfig = MANUAL_CONFIG; }
        if (!firebaseConfig) { document.getElementById('authError').classList.remove('hidden'); throw new Error("Missing Config"); }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'pikachu-party-deluxe';
        
        // --- Game Config ---
        const PLAYER_SIZE = 80;
        const MOVE_SPEED = 0.25;
        const PUSH_FORCE = 15; // å¼·åŠ›æ¨æ“ åŠ›åº¦

        // --- State ---
        let currentUser = null;
        let roomId = null;
        let isHost = false;
        let unsubscribeRoom = null;
        let myAvatarBase64 = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png";
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // æˆèªåº«
        const idioms = [
            { text: "ä¸€çŸ³äºŒï¼¿", answer: "é³¥", decoys: ["é­š", "é¦¬", "èŸ²", "è±¬"] },
            { text: "å®ˆæ ªå¾…ï¼¿", answer: "å…”", decoys: ["è™", "é¾", "è±¬", "è±¡"] },
            { text: "ç•«è›‡æ·»ï¼¿", answer: "è¶³", decoys: ["æ‰‹", "é ­", "å°¾", "ç¿¼"] },
            { text: "å°ç‰›å½ˆï¼¿", answer: "ç´", decoys: ["å‰", "é¼“", "ç¬›", "ç‘Ÿ"] },
            { text: "è™é ­è›‡ï¼¿", answer: "å°¾", decoys: ["é ­", "è…³", "èº«", "çš®"] },
            { text: "äº¡ç¾Šè£œï¼¿", answer: "ç‰¢", decoys: ["è¡£", "ç¶²", "å±‹", "ç‰†"] },
            { text: "äº•åº•ä¹‹ï¼¿", answer: "è›™", decoys: ["é­š", "è›‡", "é³¥", "äºº"] },
            { text: "ä¸‰å¿ƒå…©ï¼¿", answer: "æ„", decoys: ["æ‰‹", "è…³", "é ­", "çœ¼"] },
            { text: "é›ªä¸­é€ï¼¿", answer: "ç‚­", decoys: ["æ°´", "å†°", "èŠ±", "éŒ¢"] },
            { text: "ä¸€é³´é©šï¼¿", answer: "äºº", decoys: ["å¤©", "åœ°", "é¬¼", "ç¥"] }
        ];

        let gameState = {
            status: 'menu', 
            items: [], 
            emotes: [], // [{x, y, text, life}]
            currentIdiom: idioms[0],
            players: {}, 
            winner: null
        };

        let localPlayer = {
            id: null, role: null, x: 0, y: 0, 
            vx: 0, width: PLAYER_SIZE, height: PLAYER_SIZE,
            targetX: null, lastSync: 0
        };

        // --- Visual Assets ---
        const imgCache = {};
        function getCachedImage(id, src) {
            if(!imgCache[id]) {
                const i = new Image();
                i.crossOrigin = "anonymous";
                i.src = src;
                imgCache[id] = i;
            }
            return imgCache[id];
        }

        // --- Helper: Avatar Upload ---
        window.handleAvatarUpload = function(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const maxSize = 120; // Slightly higher quality
                    let w = img.width, h = img.height;
                    if (w > h) { if (w > maxSize) { h *= maxSize / w; w = maxSize; } }
                    else { if (h > maxSize) { w *= maxSize / h; h = maxSize; } }
                    canvas.width = w; canvas.height = h;
                    ctx.drawImage(img, 0, 0, w, h);
                    myAvatarBase64 = canvas.toDataURL('image/png', 0.8);
                    document.getElementById('avatarPreview').src = myAvatarBase64;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };

        // --- Helper: Send Emote ---
        window.sendEmote = async function(text) {
            if (!roomId || !localPlayer.id) return;
            // Send ephemeral emote event to firestore (just update a field that listeners watch)
            // Or simpler for this structure: append to a rotating list in room doc
            // For simplicity/speed in this single file, we will sync it via player state briefly or a dedicated 'effects' field
            // Let's use a "lastEmote" field on the player
            try {
                await updateDoc(getRoomRef(roomId), {
                    [`players.${localPlayer.id}.lastEmote`]: { text: text, time: Date.now() }
                });
            } catch(e) {}
        };

        // --- Auth & Init ---
        signInAnonymously(auth).catch(console.error);
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                localPlayer.id = user.uid;
                document.getElementById('authSection').classList.add('hidden');
                document.getElementById('avatarSection').classList.remove('hidden');
                document.getElementById('menuSection').classList.remove('hidden');
            }
        });

        function getRoomRef(id) { return doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${id}`); }
        function generateRoomCode() { return Math.floor(1000 + Math.random() * 9000).toString(); }

        // --- Room Operations ---
        async function createRoom() {
            if (!currentUser) return;
            roomId = generateRoomCode();
            isHost = true;
            localPlayer.role = 'p1';
            localPlayer.x = canvas.width * 0.2;

            const initialPlayers = {};
            initialPlayers[currentUser.uid] = {
                id: currentUser.uid, role: 'p1', name: document.getElementById('playerName').value || "è¨“ç·´å®¶1",
                avatar: myAvatarBase64, x: localPlayer.x, score: 0
            };

            await setDoc(getRoomRef(roomId), {
                hostId: currentUser.uid, status: 'waiting', createdAt: Date.now(),
                currentIdiomIndex: 0, spawnEvent: null, players: initialPlayers, playerCount: 1
            });
            enterWaitingRoom();
            subscribeToRoom();
        }

        async function joinRoom() {
            if (!currentUser) return;
            const code = document.getElementById('roomInput').value.trim();
            if (code.length !== 4) return alert("è«‹è¼¸å…¥4ä½æˆ¿è™Ÿ");
            roomId = code;
            isHost = false;

            const roomRef = getRoomRef(roomId);
            const roomSnap = await getDoc(roomRef);
            if (!roomSnap.exists()) return alert("æˆ¿é–“ä¸å­˜åœ¨");
            const data = roomSnap.data();

            if (data.status !== 'waiting' && !data.players[currentUser.uid]) return alert("éŠæˆ²å·²é–‹å§‹");

            // Assign Role
            let myRole = 'p2';
            if (data.players[currentUser.uid]) {
                myRole = data.players[currentUser.uid].role;
            } else {
                const count = Object.keys(data.players).length;
                if (count >= 4) return alert("æˆ¿é–“å·²æ»¿");
                const roles = ['p1','p2','p3','p4'];
                // Find first available role
                const taken = Object.values(data.players).map(p=>p.role);
                myRole = roles.find(r => !taken.includes(r)) || 'p4';
            }

            localPlayer.role = myRole;
            localPlayer.x = canvas.width * (myRole === 'p1'?0.2 : myRole==='p2'?0.4 : myRole==='p3'?0.6 : 0.8);

            await updateDoc(roomRef, {
                [`players.${currentUser.uid}`]: {
                    id: currentUser.uid, role: myRole, name: document.getElementById('playerName').value || "è¨“ç·´å®¶",
                    avatar: myAvatarBase64, x: localPlayer.x, score: 0
                }
            });
            enterWaitingRoom();
            subscribeToRoom();
        }

        function enterWaitingRoom() {
            document.getElementById('menuSection').classList.add('hidden');
            document.getElementById('avatarSection').classList.add('hidden');
            document.getElementById('waitingSection').classList.remove('hidden');
            document.getElementById('generatedRoomCode').innerText = roomId;
        }

        let lastSpawnId = null;
        let processedEmotes = {}; // { playerId: timestamp }

        function subscribeToRoom() {
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = onSnapshot(getRoomRef(roomId), (doc) => {
                if (!doc.exists()) return;
                const data = doc.data();
                gameState.players = data.players || {};

                // Handle Waiting
                if (data.status === 'waiting') {
                    updateWaitingList(gameState.players);
                    if (isHost) {
                        const count = Object.keys(gameState.players).length;
                        if (count >= 2) {
                            document.getElementById('startGameBtn').classList.remove('hidden');
                            document.getElementById('waitingText').classList.add('hidden');
                        }
                    }
                }

                // Handle Playing
                if (data.status === 'playing') {
                    if (gameState.status !== 'playing') enterGameMode();
                    
                    // Sync Remote Players & Emotes
                    Object.values(gameState.players).forEach(p => {
                        if (p.id === localPlayer.id) {
                            if (p.score !== undefined) localPlayer.serverScore = p.score;
                        }
                        // Check for new emote
                        if (p.lastEmote && (!processedEmotes[p.id] || processedEmotes[p.id] < p.lastEmote.time)) {
                            processedEmotes[p.id] = p.lastEmote.time;
                            spawnEmote(p.id, p.lastEmote.text);
                        }
                    });
                }

                // Idioms & Spawning
                if (data.currentIdiomIndex !== undefined) {
                    gameState.currentIdiom = idioms[data.currentIdiomIndex % idioms.length];
                    document.getElementById('idiomDisplay').innerText = gameState.currentIdiom.text;
                }
                if (!isHost && data.spawnEvent && data.spawnEvent.id !== lastSpawnId) {
                    spawnItemFromEvent(data.spawnEvent);
                    lastSpawnId = data.spawnEvent.id;
                }

                updateScoreboard();
                if (data.status === 'gameover') endGame(data);
            });
        }

        function updateWaitingList(players) {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            Object.values(players).forEach(p => {
                const div = document.createElement('div');
                div.className = 'flex flex-col items-center animate-pop-in transition-all';
                div.innerHTML = `
                    <div class="relative">
                        <img src="${p.avatar}" class="w-16 h-16 rounded-full border-4 ${getRoleColorClass(p.role)} bg-white object-cover shadow-md">
                        <div class="absolute -bottom-2 -right-2 bg-white rounded-full p-1 shadow">
                            <i class="fas fa-check-circle text-green-500"></i>
                        </div>
                    </div>
                    <span class="text-xs font-bold mt-2 text-gray-700 bg-white/80 px-2 py-0.5 rounded-full shadow-sm truncate max-w-[80px]">${p.name}</span>
                `;
                list.appendChild(div);
            });
        }

        // --- Game Setup ---
        document.getElementById('startGameBtn').addEventListener('click', async () => {
            await updateDoc(getRoomRef(roomId), { status: 'playing' });
        });

        function enterGameMode() {
            gameState.status = 'playing';
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            document.getElementById('roomCodeDisplay').innerText = `ROOM: ${roomId}`;
            resizeCanvas();

            const board = document.getElementById('scoreboardArea');
            board.innerHTML = '';
            Object.values(gameState.players).sort((a,b) => a.role.localeCompare(b.role)).forEach(p => {
                const card = document.createElement('div');
                card.className = `flex-1 ${getRoleBgClass(p.role)} rounded-2xl p-2 shadow-lg text-center border-b-8 border-black/10 transform transition-all duration-300 hover:scale-105`;
                card.innerHTML = `
                    <div class="flex items-center justify-center gap-2 mb-1">
                         <img src="${p.avatar}" class="w-8 h-8 rounded-full bg-white object-cover border-2 border-white/50 shadow-inner">
                         <p class="text-xs text-white font-bold truncate max-w-[60px]">${p.name}</p>
                    </div>
                    <p class="text-3xl text-white font-black drop-shadow-md" id="score-val-${p.id}">0</p>
                `;
                board.appendChild(card);
            });

            if (isHost) hostLoop();
            startGameLoop();
        }

        function updateScoreboard() {
            if (gameState.status !== 'playing') return;
            Object.values(gameState.players).forEach(p => {
                const el = document.getElementById(`score-val-${p.id}`);
                if(el) el.innerText = p.score;
            });
        }

        // --- Logic: Host & Physics ---
        function hostLoop() {
            if (gameState.status !== 'playing') return;
            setTimeout(() => {
                if (gameState.status !== 'playing') return;
                const idiom = gameState.currentIdiom;
                const isCorrect = Math.random() < 0.45; 
                const text = isCorrect ? idiom.answer : idiom.decoys[Math.floor(Math.random() * idiom.decoys.length)];
                
                const event = {
                    id: Date.now() + Math.random(),
                    text: text,
                    isCorrect: isCorrect,
                    x: Math.random() * (canvas.width - 100) + 50,
                    vy: 3 + Math.random() * 3 
                };

                updateDoc(getRoomRef(roomId), { spawnEvent: event }).catch(console.error);
                spawnItemFromEvent(event);
                hostLoop();
            }, 1200 + Math.random() * 800);
        }

        function spawnItemFromEvent(event) {
            gameState.items.push({ ...event, y: -80, radius: 40, active: true, rotation: 0, vRot: (Math.random()-0.5)*0.2 });
        }

        function spawnEmote(playerId, text) {
            const p = gameState.players[playerId];
            if(!p) return;
            // Get position based on local or remote
            let x = (playerId === localPlayer.id) ? localPlayer.x : p.x;
            // If x is undefined for some reason, default to center
            if (x === undefined) x = canvas.width/2;
            
            gameState.emotes.push({
                x: x + PLAYER_SIZE/2,
                y: canvas.height - 150,
                text: text,
                life: 1.0,
                vy: -1
            });
        }

        let lastSyncTime = 0;
        function syncPosition() {
            const now = Date.now();
            if (now - lastSyncTime > 50) { 
                updateDoc(getRoomRef(roomId), { [`players.${localPlayer.id}.x`]: localPlayer.x }).catch(()=>{}); 
                lastSyncTime = now;
            }
        }

        async function handleScore(isCorrect) {
            const change = isCorrect ? 10 : -5;
            // Screen shake or effect here could be added
            try {
                await updateDoc(getRoomRef(roomId), { 
                    [`players.${localPlayer.id}.score`]: increment(change) 
                });
                if (isCorrect && isHost) {
                    const nextIndex = Math.floor(Math.random() * idioms.length);
                    await updateDoc(getRoomRef(roomId), { currentIdiomIndex: nextIndex });
                }
            } catch (e) {}
        }

        // --- Main Game Loop ---
        function startGameLoop() {
            function loop() {
                if (gameState.status !== 'playing') return;
                update();
                draw();
                requestAnimationFrame(loop);
            }
            loop();
        }

        function update() {
            // 1. Movement
            if (localPlayer.targetX !== null) {
                const center = localPlayer.x + localPlayer.width/2;
                const dx = localPlayer.targetX - center;
                localPlayer.x += dx * MOVE_SPEED;
                if(Math.abs(dx) < 2) localPlayer.targetX = null;
            }
            
            // 2. Physics: Boundary
            if (localPlayer.x < 0) localPlayer.x = 0;
            if (localPlayer.x + localPlayer.width > canvas.width) localPlayer.x = canvas.width - localPlayer.width;

            // 3. Physics: PLAYER-PLAYER COLLISION (Anti-Overlap / Pushing)
            const myCenter = localPlayer.x + localPlayer.width/2;
            Object.values(gameState.players).forEach(p => {
                if (p.id === localPlayer.id) return;
                
                // Use last known X for others
                const otherX = p.x !== undefined ? p.x : 0;
                const otherCenter = otherX + PLAYER_SIZE/2;
                const dist = Math.abs(myCenter - otherCenter);
                const minDist = PLAYER_SIZE * 0.9; // Allow slight overlap but push hard

                if (dist < minDist) {
                    // Collision detected! Push local player away
                    const pushAmount = (minDist - dist) * 0.2; // Smooth push
                    if (myCenter < otherCenter) {
                        localPlayer.x -= pushAmount;
                    } else {
                        localPlayer.x += pushAmount;
                    }
                }
            });

            if (Math.abs(localPlayer.x - (gameState.players[localPlayer.id]?.x || 0)) > 2) {
                syncPosition();
            }

            // 4. Items Logic
            gameState.items.forEach(item => {
                if (!item.active) return;
                item.y += item.vy;
                item.rotation += item.vRot;
                
                // Collision with Local Player
                const itemCenterX = item.x;
                const itemCenterY = item.y;
                const playerCenterX = localPlayer.x + PLAYER_SIZE/2;
                const playerCenterY = localPlayer.y + PLAYER_SIZE/2; // Approx

                // Simple Circle-Circle collision for cleaner feel
                const dx = itemCenterX - playerCenterX;
                const dy = itemCenterY - playerCenterY;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < item.radius + PLAYER_SIZE/3) {
                    item.active = false;
                    handleScore(item.isCorrect);
                    createParticles(item.x, item.y, item.isCorrect ? '#FFD700' : '#888');
                }
                if (item.y > canvas.height + 60) item.active = false;
            });
            gameState.items = gameState.items.filter(i => i.active);

            // 5. Emotes
            gameState.emotes.forEach(e => {
                e.y += e.vy;
                e.life -= 0.015;
            });
            gameState.emotes = gameState.emotes.filter(e => e.life > 0);

            updateParticles();
        }

        // --- Deluxe Drawing Engine ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Draw Background Details (Clouds/Ground)
            drawBackground();

            // 2. Draw Items (Detailed Pokeballs)
            gameState.items.forEach(item => {
                drawPokeball(item.x, item.y, item.radius, item.rotation, item.text, item.isCorrect);
            });

            // 3. Draw Players
            Object.values(gameState.players).forEach(p => {
                const isLocal = p.id === localPlayer.id;
                const x = isLocal ? localPlayer.x : (p.x || 0);
                const y = localPlayer.y;
                drawPlayer(x, y, p.role, p.avatar, isLocal, p.name);
            });

            // 4. Particles & Emotes
            drawParticles();
            drawEmotes();
        }

        function drawBackground() {
            // Ground
            ctx.fillStyle = '#4ade80'; // Green grass
            ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
            ctx.fillStyle = '#22c55e'; // Darker grass top
            ctx.fillRect(0, canvas.height - 45, canvas.width, 10);
        }

        function drawPokeball(x, y, r, rotation, text, isCorrect) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Shadow
            ctx.beginPath();
            ctx.arc(5, 5, r, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fill();

            // Ball Body
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); 
            ctx.fillStyle = 'white'; ctx.fill(); 
            ctx.strokeStyle = '#222'; ctx.lineWidth = 3; ctx.stroke();

            // Top Half (Red or Blue for decoy?) - Let's keep it Classic Red
            ctx.beginPath(); ctx.arc(0, 0, r, Math.PI, 0); 
            ctx.fillStyle = isCorrect ? '#ef4444' : '#ef4444'; ctx.fill(); // Always red ball, text matters
            ctx.stroke();

            // Center Band
            ctx.beginPath(); ctx.rect(-r, -r*0.1, r*2, r*0.2); 
            ctx.fillStyle = '#222'; ctx.fill();

            // Center Button
            ctx.beginPath(); ctx.arc(0, 0, r*0.25, 0, Math.PI*2); ctx.fillStyle = '#222'; ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, r*0.15, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill();

            // Text (The Kanji) - Floating ABOVE the ball (Counter-rotate to keep upright)
            ctx.rotate(-rotation);
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 4;
            ctx.fillStyle = "white";
            ctx.font = "900 36px 'Noto Sans TC'";
            ctx.strokeStyle = "black"; ctx.lineWidth = 6;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.strokeText(text, 0, 0);
            ctx.fillText(text, 0, 0);
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function drawPlayer(x, y, role, avatarSrc, isLocal, name) {
            const centerX = x + PLAYER_SIZE/2;
            const centerY = y + PLAYER_SIZE/2;
            
            ctx.save();
            ctx.translate(centerX, centerY);

            // Shadow
            ctx.beginPath();
            ctx.ellipse(0, PLAYER_SIZE/2 - 5, PLAYER_SIZE/2, 12, 0, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fill();

            // Role Aura/Ring
            const color = getRoleColorHex(role);
            ctx.beginPath();
            ctx.arc(0, 0, PLAYER_SIZE/2 + 6, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.stroke();

            // Avatar
            const img = getCachedImage(role+name, avatarSrc);
            if(img && img.complete) {
                ctx.save();
                ctx.beginPath(); ctx.arc(0, 0, PLAYER_SIZE/2, 0, Math.PI*2); ctx.clip();
                ctx.drawImage(img, -PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE);
                ctx.restore();
            }

            // Name Tag
            ctx.fillStyle = "white";
            ctx.font = "bold 12px sans-serif";
            ctx.textAlign = "center";
            ctx.shadowColor="black"; ctx.shadowBlur=2;
            ctx.fillText(name, 0, -PLAYER_SIZE/2 - 10);
            ctx.shadowBlur=0;

            // "ME" Indicator
            if(isLocal) {
                ctx.beginPath();
                ctx.moveTo(0, -PLAYER_SIZE/2 - 25);
                ctx.lineTo(-10, -PLAYER_SIZE/2 - 35);
                ctx.lineTo(10, -PLAYER_SIZE/2 - 35);
                ctx.fillStyle = '#ef4444'; ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            }

            ctx.restore();
        }

        function drawEmotes() {
            gameState.emotes.forEach(e => {
                ctx.save();
                ctx.globalAlpha = e.life;
                ctx.translate(e.x, e.y);
                
                // Bubble shape
                ctx.beginPath();
                ctx.roundRect(-25, -20, 50, 40, 10);
                ctx.fillStyle = 'white'; ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke();
                
                // Text
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(e.text, 0, 0);
                
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        // --- Particles ---
        let particles = [];
        function createParticles(x, y, color) {
            for(let i=0; i<15; i++) {
                particles.push({
                    x, y, 
                    vx: (Math.random()-0.5)*15, 
                    vy: (Math.random()-0.5)*15, 
                    life: 1, 
                    color: color,
                    size: Math.random() * 8 + 2
                });
            }
        }
        function updateParticles() {
            particles.forEach(p => { 
                p.x += p.vx; p.y += p.vy; p.life -= 0.04; p.vy += 0.5; // gravity
            });
            particles = particles.filter(p => p.life > 0);
        }
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                if(Math.random()>0.5) ctx.rect(p.x, p.y, p.size, p.size);
                else ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // --- Helpers ---
        function getRoleColorClass(role) {
            if(role==='p1') return 'border-yellow-400';
            if(role==='p2') return 'border-purple-400';
            if(role==='p3') return 'border-blue-400';
            if(role==='p4') return 'border-red-400';
            return 'border-gray-400';
        }
        function getRoleBgClass(role) {
            if(role==='p1') return 'bg-yellow-400';
            if(role==='p2') return 'bg-purple-400';
            if(role==='p3') return 'bg-blue-400';
            if(role==='p4') return 'bg-red-400';
            return 'bg-gray-400';
        }
        function getRoleColorHex(role) {
            if(role==='p1') return '#facc15';
            if(role==='p2') return '#c084fc';
            if(role==='p3') return '#60a5fa';
            if(role==='p4') return '#f87171';
            return '#9ca3af';
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            localPlayer.y = canvas.height - PLAYER_SIZE - 20;
        }
        window.addEventListener('resize', resizeCanvas);
        
        function handleInput(clientX) {
            if (gameState.status !== 'playing') return;
            localPlayer.targetX = clientX;
        }
        canvas.addEventListener('mousemove', e => handleInput(e.clientX));
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });

        document.getElementById('createBtn').addEventListener('click', createRoom);
        document.getElementById('joinBtn').addEventListener('click', joinRoom);

        function endGame(data) {
            const winners = Object.values(data.players).sort((a,b) => b.score - a.score);
            const winner = winners[0];
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('winnerText').innerText = `ğŸ† ${winner.name} ç²å‹ï¼`;
            const list = document.getElementById('finalScores');
            list.innerHTML = '';
            winners.forEach(p => {
                list.innerHTML += `
                    <div class="flex justify-between items-center bg-gray-100 p-4 rounded-xl shadow-sm">
                        <div class="flex items-center gap-3">
                             <img src="${p.avatar}" class="w-10 h-10 rounded-full bg-white object-cover shadow-sm">
                             <span class="font-bold text-gray-700 text-lg">${p.name}</span>
                        </div>
                        <span class="font-black text-2xl text-blue-600">${p.score}</span>
                    </div>
                `;
            });
        }
    </script>
</body>
</html>
